#include "Data.cginc"
#pragma kernel CamFrustumCalc

#define NUM_THREADS 2
#define NUM_THREADS_X NUM_THREADS
#define NUM_THREADS_Y NUM_THREADS

float4 frustumPosIndex[2];//[0].xy, [0].zw, [1].xy
RWTexture2D<float4> testTexture;
RWStructuredBuffer<uint> counter;//计数器
RWStructuredBuffer<uint> indirectDataBuffer;
AppendStructuredBuffer<float4> renderPosAppend;
AppendStructuredBuffer<float3> appendBuffer;

struct Triangle {
    int2 a, b, c;
    int2 ab() { return b - a; }
    int2 ac() { return c - a; }
    int2 bc() { return c - b; }
    half area() { return abs(determinant(half2x2(ab().x, ab().y,ac().x, ac().y))) / 2; }
};

Triangle NewTriangle(int2 a, int2 b, int2 c) {
    Triangle r; r.a = a; r.b = b, r.c = c;
    return r;
}

float PointInTriangle(int2 a, int2 b, int2 c, int2 p) {
    Triangle abc = NewTriangle(a, b, c);
    half sabc = NewTriangle(a, b, c).area(),
        spbc = NewTriangle(p, b, c).area(),
        spba = NewTriangle(p, b, a).area(),
        spac = NewTriangle(p, a, c).area();
    return step(spbc + spba + spac - sabc, 0);
}

[numthreads(NUM_THREADS_X, NUM_THREADS_Y,1)]
void CamFrustumCalc (uint3 id : SV_DispatchThreadID)
{
    //numthreads
    uint hasGrass = PointInTriangle(frustumPosIndex[0].xy, frustumPosIndex[0].zw,
        frustumPosIndex[1].xy, id.xy);

    int globIdFlattened = flattenId(id.xy, threadSize.xy)//globalId = 贴图内index+起始点index
        + flattenId(_FrustumStartPosI.xy, terrainSize.xy);
    terrainDataBuffer[globIdFlattened].hasGrass = hasGrass;
    //instanceCount += hasGrass;
    int count;
    //函数被封装，只能使用条件分支
    if (hasGrass) {
        count = counter.IncrementCounter();
        counter[0] = max(count, counter[0]);
        indirectDataBuffer[1] = max(indirectDataBuffer[1], count);

        //renderPosAppend.Append(getTerrainPos(id.xy + _FrustumStartPosI.xy));
        renderPosAppend.Append(float4(1,2,1,1));
    }

    testTexture[id.xy] = float4((id * _TileSize).xy, hasGrass,0);
    //indirectDataBuffer[1] = indirectDataBuffer[1]+ hasGrass;
    //testTexture[id.xy] = float4(1,1,1,0.5);
    appendBuffer.Append(float3(0,0,0));
}

